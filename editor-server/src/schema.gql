# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddDancerInput {
  name: String!
}

input AddPartInput {
  dancerName: String!
  name: String!
  type: String!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Color {
  color: String!
  colorCode: String!
}

input ColorCreateInput {
  color: String!
  colorCode: String!
}

type ColorMap {
  colorMap: ColorMapCustomScalar!
}

"""Color map scalar type"""
scalar ColorMapCustomScalar

input ColorOrderByWithRelationInput {
  color: SortOrder
  colorCode: SortOrder
}

type ColorPayload {
  color: String!
  colorCode: String
  editBy: Int!
  mutation: String!
  renameColor: String
}

type ColorResponse {
  color: String!
  colorCode: String!
  msg: String
  ok: Boolean
}

enum ColorScalarFieldEnum {
  color
  colorCode
}

input ColorWhereInput {
  AND: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  color: StringFilter
  colorCode: StringFilter
}

input ColorWhereUniqueInput {
  color: String
}

type ControlData {
  frame: ControlFrame!
  frameId: Int!
  part: Part!
  partId: Int!
  value: JSON!
}

input ControlDataCreateManyFrameInput {
  partId: Int!
  value: JSON!
}

input ControlDataCreateManyFrameInputEnvelope {
  data: [ControlDataCreateManyFrameInput!]!
  skipDuplicates: Boolean
}

input ControlDataCreateManyPartInput {
  frameId: Int!
  value: JSON!
}

input ControlDataCreateManyPartInputEnvelope {
  data: [ControlDataCreateManyPartInput!]!
  skipDuplicates: Boolean
}

input ControlDataCreateNestedManyWithoutFrameInput {
  connect: [ControlDataWhereUniqueInput!]
  connectOrCreate: [ControlDataCreateOrConnectWithoutFrameInput!]
  create: [ControlDataCreateWithoutFrameInput!]
  createMany: ControlDataCreateManyFrameInputEnvelope
}

input ControlDataCreateNestedManyWithoutPartInput {
  connect: [ControlDataWhereUniqueInput!]
  connectOrCreate: [ControlDataCreateOrConnectWithoutPartInput!]
  create: [ControlDataCreateWithoutPartInput!]
  createMany: ControlDataCreateManyPartInputEnvelope
}

input ControlDataCreateOrConnectWithoutFrameInput {
  create: ControlDataCreateWithoutFrameInput!
  where: ControlDataWhereUniqueInput!
}

input ControlDataCreateOrConnectWithoutPartInput {
  create: ControlDataCreateWithoutPartInput!
  where: ControlDataWhereUniqueInput!
}

input ControlDataCreateWithoutFrameInput {
  part: PartCreateNestedOneWithoutControlDataInput!
  value: JSON!
}

input ControlDataCreateWithoutPartInput {
  frame: ControlFrameCreateNestedOneWithoutControlDatasInput!
  value: JSON!
}

input ControlDataListRelationFilter {
  every: ControlDataWhereInput
  none: ControlDataWhereInput
  some: ControlDataWhereInput
}

input ControlDataOrderByRelationAggregateInput {
  _count: SortOrder
}

input ControlDataOrderByWithRelationInput {
  frame: ControlFrameOrderByWithRelationInput
  frameId: SortOrder
  part: PartOrderByWithRelationInput
  partId: SortOrder
  value: SortOrder
}

input ControlDataPartIdFrameIdCompoundUniqueInput {
  frameId: Int!
  partId: Int!
}

enum ControlDataScalarFieldEnum {
  frameId
  partId
  value
}

input ControlDataScalarWhereInput {
  AND: [ControlDataScalarWhereInput!]
  NOT: [ControlDataScalarWhereInput!]
  OR: [ControlDataScalarWhereInput!]
  frameId: IntFilter
  partId: IntFilter
  value: JsonFilter
}

input ControlDataUpdateManyMutationInput {
  value: JSON
}

input ControlDataUpdateManyWithWhereWithoutFrameInput {
  data: ControlDataUpdateManyMutationInput!
  where: ControlDataScalarWhereInput!
}

input ControlDataUpdateManyWithWhereWithoutPartInput {
  data: ControlDataUpdateManyMutationInput!
  where: ControlDataScalarWhereInput!
}

input ControlDataUpdateManyWithoutFrameNestedInput {
  connect: [ControlDataWhereUniqueInput!]
  connectOrCreate: [ControlDataCreateOrConnectWithoutFrameInput!]
  create: [ControlDataCreateWithoutFrameInput!]
  createMany: ControlDataCreateManyFrameInputEnvelope
  delete: [ControlDataWhereUniqueInput!]
  deleteMany: [ControlDataScalarWhereInput!]
  disconnect: [ControlDataWhereUniqueInput!]
  set: [ControlDataWhereUniqueInput!]
  update: [ControlDataUpdateWithWhereUniqueWithoutFrameInput!]
  updateMany: [ControlDataUpdateManyWithWhereWithoutFrameInput!]
  upsert: [ControlDataUpsertWithWhereUniqueWithoutFrameInput!]
}

input ControlDataUpdateManyWithoutPartNestedInput {
  connect: [ControlDataWhereUniqueInput!]
  connectOrCreate: [ControlDataCreateOrConnectWithoutPartInput!]
  create: [ControlDataCreateWithoutPartInput!]
  createMany: ControlDataCreateManyPartInputEnvelope
  delete: [ControlDataWhereUniqueInput!]
  deleteMany: [ControlDataScalarWhereInput!]
  disconnect: [ControlDataWhereUniqueInput!]
  set: [ControlDataWhereUniqueInput!]
  update: [ControlDataUpdateWithWhereUniqueWithoutPartInput!]
  updateMany: [ControlDataUpdateManyWithWhereWithoutPartInput!]
  upsert: [ControlDataUpsertWithWhereUniqueWithoutPartInput!]
}

input ControlDataUpdateWithWhereUniqueWithoutFrameInput {
  data: ControlDataUpdateWithoutFrameInput!
  where: ControlDataWhereUniqueInput!
}

input ControlDataUpdateWithWhereUniqueWithoutPartInput {
  data: ControlDataUpdateWithoutPartInput!
  where: ControlDataWhereUniqueInput!
}

input ControlDataUpdateWithoutFrameInput {
  part: PartUpdateOneRequiredWithoutControlDataNestedInput
  value: JSON
}

input ControlDataUpdateWithoutPartInput {
  frame: ControlFrameUpdateOneRequiredWithoutControlDatasNestedInput
  value: JSON
}

input ControlDataUpsertWithWhereUniqueWithoutFrameInput {
  create: ControlDataCreateWithoutFrameInput!
  update: ControlDataUpdateWithoutFrameInput!
  where: ControlDataWhereUniqueInput!
}

input ControlDataUpsertWithWhereUniqueWithoutPartInput {
  create: ControlDataCreateWithoutPartInput!
  update: ControlDataUpdateWithoutPartInput!
  where: ControlDataWhereUniqueInput!
}

input ControlDataWhereInput {
  AND: [ControlDataWhereInput!]
  NOT: [ControlDataWhereInput!]
  OR: [ControlDataWhereInput!]
  frame: ControlFrameRelationFilter
  frameId: IntFilter
  part: PartRelationFilter
  partId: IntFilter
  value: JsonFilter
}

input ControlDataWhereUniqueInput {
  partId_frameId: ControlDataPartIdFrameIdCompoundUniqueInput
}

type ControlFrame {
  _count: ControlFrameCount
  controlDatas(cursor: ControlDataWhereUniqueInput, distinct: [ControlDataScalarFieldEnum!], orderBy: [ControlDataOrderByWithRelationInput!], skip: Int, take: Int, where: ControlDataWhereInput): [ControlData!]!
  editing: EditingControlFrame
  fade: Boolean!
  id: Int!
  start: Int!
}

type ControlFrameCount {
  controlDatas: Int!
}

input ControlFrameCreateNestedOneWithoutControlDatasInput {
  connect: ControlFrameWhereUniqueInput
  connectOrCreate: ControlFrameCreateOrConnectWithoutControlDatasInput
  create: ControlFrameCreateWithoutControlDatasInput
}

input ControlFrameCreateNestedOneWithoutEditingInput {
  connect: ControlFrameWhereUniqueInput
  connectOrCreate: ControlFrameCreateOrConnectWithoutEditingInput
  create: ControlFrameCreateWithoutEditingInput
}

input ControlFrameCreateOrConnectWithoutControlDatasInput {
  create: ControlFrameCreateWithoutControlDatasInput!
  where: ControlFrameWhereUniqueInput!
}

input ControlFrameCreateOrConnectWithoutEditingInput {
  create: ControlFrameCreateWithoutEditingInput!
  where: ControlFrameWhereUniqueInput!
}

input ControlFrameCreateWithoutControlDatasInput {
  editing: EditingControlFrameCreateNestedOneWithoutEditingFrameInput
  fade: Boolean!
  start: Int!
}

input ControlFrameCreateWithoutEditingInput {
  controlDatas: ControlDataCreateNestedManyWithoutFrameInput
  fade: Boolean!
  start: Int!
}

input ControlFrameOrderByWithRelationInput {
  controlDatas: ControlDataOrderByRelationAggregateInput
  editing: EditingControlFrameOrderByWithRelationInput
  fade: SortOrder
  id: SortOrder
  start: SortOrder
}

input ControlFrameRelationFilter {
  is: ControlFrameWhereInput
  isNot: ControlFrameWhereInput
}

input ControlFrameUpdateOneRequiredWithoutControlDatasNestedInput {
  connect: ControlFrameWhereUniqueInput
  connectOrCreate: ControlFrameCreateOrConnectWithoutControlDatasInput
  create: ControlFrameCreateWithoutControlDatasInput
  update: ControlFrameUpdateWithoutControlDatasInput
  upsert: ControlFrameUpsertWithoutControlDatasInput
}

input ControlFrameUpdateOneWithoutEditingNestedInput {
  connect: ControlFrameWhereUniqueInput
  connectOrCreate: ControlFrameCreateOrConnectWithoutEditingInput
  create: ControlFrameCreateWithoutEditingInput
  delete: Boolean
  disconnect: Boolean
  update: ControlFrameUpdateWithoutEditingInput
  upsert: ControlFrameUpsertWithoutEditingInput
}

input ControlFrameUpdateWithoutControlDatasInput {
  editing: EditingControlFrameUpdateOneWithoutEditingFrameNestedInput
  fade: BoolFieldUpdateOperationsInput
  start: IntFieldUpdateOperationsInput
}

input ControlFrameUpdateWithoutEditingInput {
  controlDatas: ControlDataUpdateManyWithoutFrameNestedInput
  fade: BoolFieldUpdateOperationsInput
  start: IntFieldUpdateOperationsInput
}

input ControlFrameUpsertWithoutControlDatasInput {
  create: ControlFrameCreateWithoutControlDatasInput!
  update: ControlFrameUpdateWithoutControlDatasInput!
}

input ControlFrameUpsertWithoutEditingInput {
  create: ControlFrameCreateWithoutEditingInput!
  update: ControlFrameUpdateWithoutEditingInput!
}

input ControlFrameWhereInput {
  AND: [ControlFrameWhereInput!]
  NOT: [ControlFrameWhereInput!]
  OR: [ControlFrameWhereInput!]
  controlDatas: ControlDataListRelationFilter
  editing: EditingControlFrameRelationFilter
  fade: BoolFilter
  id: IntFilter
  start: IntFilter
}

input ControlFrameWhereUniqueInput {
  id: Int
  start: Int
}

type ControlMap {
  frameIds: ControlMapQueryObjectId!
}

"""Mongo object id scalar type"""
scalar ControlMapMutationObjectId

type ControlMapPayload {
  editBy: Int!
  frame: ControlMapMutationObjectId!
}

"""Mongo object id scalar type"""
scalar ControlMapQueryObjectId

type ControlRecordPayload {
  addID: [Int!]!
  deleteID: [Int!]!
  editBy: Int!
  index: Int!
  mutation: String!
  updateID: [Int!]!
}

type Dancer {
  _count: DancerCount
  id: Int!
  name: String!
  parts(cursor: PartWhereUniqueInput, distinct: [PartScalarFieldEnum!], orderBy: [PartOrderByWithRelationInput!], skip: Int, take: Int, where: PartWhereInput): [Part!]!
  positionData(cursor: PositionDataWhereUniqueInput, distinct: [PositionDataScalarFieldEnum!], orderBy: [PositionDataOrderByWithRelationInput!], skip: Int, take: Int, where: PositionDataWhereInput): [PositionData!]!
}

type DancerCount {
  parts: Int!
  positionData: Int!
}

input DancerCreateNestedOneWithoutPartsInput {
  connect: DancerWhereUniqueInput
  connectOrCreate: DancerCreateOrConnectWithoutPartsInput
  create: DancerCreateWithoutPartsInput
}

input DancerCreateNestedOneWithoutPositionDataInput {
  connect: DancerWhereUniqueInput
  connectOrCreate: DancerCreateOrConnectWithoutPositionDataInput
  create: DancerCreateWithoutPositionDataInput
}

input DancerCreateOrConnectWithoutPartsInput {
  create: DancerCreateWithoutPartsInput!
  where: DancerWhereUniqueInput!
}

input DancerCreateOrConnectWithoutPositionDataInput {
  create: DancerCreateWithoutPositionDataInput!
  where: DancerWhereUniqueInput!
}

input DancerCreateWithoutPartsInput {
  name: String!
  positionData: PositionDataCreateNestedManyWithoutDancerInput
}

input DancerCreateWithoutPositionDataInput {
  name: String!
  parts: PartCreateNestedManyWithoutDancerInput
}

input DancerOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  parts: PartOrderByRelationAggregateInput
  positionData: PositionDataOrderByRelationAggregateInput
}

type DancerPayload {
  dancerData: Dancer
  editBy: Int!
  mutation: dancerMutation!
}

input DancerRelationFilter {
  is: DancerWhereInput
  isNot: DancerWhereInput
}

type DancerResponse {
  dancerData: Dancer
  msg: String
  ok: Boolean!
}

input DancerUpdateOneRequiredWithoutPartsNestedInput {
  connect: DancerWhereUniqueInput
  connectOrCreate: DancerCreateOrConnectWithoutPartsInput
  create: DancerCreateWithoutPartsInput
  update: DancerUpdateWithoutPartsInput
  upsert: DancerUpsertWithoutPartsInput
}

input DancerUpdateOneRequiredWithoutPositionDataNestedInput {
  connect: DancerWhereUniqueInput
  connectOrCreate: DancerCreateOrConnectWithoutPositionDataInput
  create: DancerCreateWithoutPositionDataInput
  update: DancerUpdateWithoutPositionDataInput
  upsert: DancerUpsertWithoutPositionDataInput
}

input DancerUpdateWithoutPartsInput {
  name: StringFieldUpdateOperationsInput
  positionData: PositionDataUpdateManyWithoutDancerNestedInput
}

input DancerUpdateWithoutPositionDataInput {
  name: StringFieldUpdateOperationsInput
  parts: PartUpdateManyWithoutDancerNestedInput
}

input DancerUpsertWithoutPartsInput {
  create: DancerCreateWithoutPartsInput!
  update: DancerUpdateWithoutPartsInput!
}

input DancerUpsertWithoutPositionDataInput {
  create: DancerCreateWithoutPositionDataInput!
  update: DancerUpdateWithoutPositionDataInput!
}

input DancerWhereInput {
  AND: [DancerWhereInput!]
  NOT: [DancerWhereInput!]
  OR: [DancerWhereInput!]
  id: IntFilter
  name: StringFilter
  parts: PartListRelationFilter
  positionData: PositionDataListRelationFilter
}

input DancerWhereUniqueInput {
  id: Int
}

input DeleteControlFrameInput {
  frameID: Int!
}

type DeleteLEDEffectResponse {
  msg: String
  ok: Boolean!
}

input DeleteLEDInput {
  effectName: String!
  partName: String!
}

input DeletePartInput {
  id: Int!
}

input DeletePositionFrameInput {
  frameID: Int!
}

input EditControlFrameInput {
  fade: Boolean
  frameID: Int!
  start: Int
}

input EditControlMapInput {
  controlData: [[[String!]!]!]!
  fade: Boolean
  frameId: Int!
}

input EditPartInput {
  id: Int!
  name: String!
  type: String!
}

input EditPositionFrameInput {
  frameID: Int!
  start: Int!
}

input EditPositionMapInput {
  frameId: Int!
  positionData: [[Float!]!]!
}

type EditingControlFrame {
  editingFrame: ControlFrame
  frameId: Int
  user: User!
  userId: Int!
}

input EditingControlFrameCreateNestedOneWithoutEditingFrameInput {
  connect: EditingControlFrameWhereUniqueInput
  connectOrCreate: EditingControlFrameCreateOrConnectWithoutEditingFrameInput
  create: EditingControlFrameCreateWithoutEditingFrameInput
}

input EditingControlFrameCreateNestedOneWithoutUserInput {
  connect: EditingControlFrameWhereUniqueInput
  connectOrCreate: EditingControlFrameCreateOrConnectWithoutUserInput
  create: EditingControlFrameCreateWithoutUserInput
}

input EditingControlFrameCreateOrConnectWithoutEditingFrameInput {
  create: EditingControlFrameCreateWithoutEditingFrameInput!
  where: EditingControlFrameWhereUniqueInput!
}

input EditingControlFrameCreateOrConnectWithoutUserInput {
  create: EditingControlFrameCreateWithoutUserInput!
  where: EditingControlFrameWhereUniqueInput!
}

input EditingControlFrameCreateWithoutEditingFrameInput {
  user: UserCreateNestedOneWithoutEditingControlFrameIdInput!
}

input EditingControlFrameCreateWithoutUserInput {
  editingFrame: ControlFrameCreateNestedOneWithoutEditingInput
}

input EditingControlFrameOrderByWithRelationInput {
  editingFrame: ControlFrameOrderByWithRelationInput
  frameId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingControlFrameRelationFilter {
  is: EditingControlFrameWhereInput
  isNot: EditingControlFrameWhereInput
}

input EditingControlFrameUpdateOneWithoutEditingFrameNestedInput {
  connect: EditingControlFrameWhereUniqueInput
  connectOrCreate: EditingControlFrameCreateOrConnectWithoutEditingFrameInput
  create: EditingControlFrameCreateWithoutEditingFrameInput
  delete: Boolean
  disconnect: Boolean
  update: EditingControlFrameUpdateWithoutEditingFrameInput
  upsert: EditingControlFrameUpsertWithoutEditingFrameInput
}

input EditingControlFrameUpdateOneWithoutUserNestedInput {
  connect: EditingControlFrameWhereUniqueInput
  connectOrCreate: EditingControlFrameCreateOrConnectWithoutUserInput
  create: EditingControlFrameCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: EditingControlFrameUpdateWithoutUserInput
  upsert: EditingControlFrameUpsertWithoutUserInput
}

input EditingControlFrameUpdateWithoutEditingFrameInput {
  user: UserUpdateOneRequiredWithoutEditingControlFrameIdNestedInput
}

input EditingControlFrameUpdateWithoutUserInput {
  editingFrame: ControlFrameUpdateOneWithoutEditingNestedInput
}

input EditingControlFrameUpsertWithoutEditingFrameInput {
  create: EditingControlFrameCreateWithoutEditingFrameInput!
  update: EditingControlFrameUpdateWithoutEditingFrameInput!
}

input EditingControlFrameUpsertWithoutUserInput {
  create: EditingControlFrameCreateWithoutUserInput!
  update: EditingControlFrameUpdateWithoutUserInput!
}

input EditingControlFrameWhereInput {
  AND: [EditingControlFrameWhereInput!]
  NOT: [EditingControlFrameWhereInput!]
  OR: [EditingControlFrameWhereInput!]
  editingFrame: ControlFrameRelationFilter
  frameId: IntNullableFilter
  user: UserRelationFilter
  userId: IntFilter
}

input EditingControlFrameWhereUniqueInput {
  frameId: Int
  userId: Int
}

type EditingLEDEffect {
  LEDEffectId: Int
  userId: Int!
}

input EditingLEDEffectCreateNestedOneWithoutEditingLEDEffectInput {
  connect: EditingLEDEffectWhereUniqueInput
  connectOrCreate: EditingLEDEffectCreateOrConnectWithoutEditingLEDEffectInput
  create: EditingLEDEffectCreateWithoutEditingLEDEffectInput
}

input EditingLEDEffectCreateNestedOneWithoutUserInput {
  connect: EditingLEDEffectWhereUniqueInput
  connectOrCreate: EditingLEDEffectCreateOrConnectWithoutUserInput
  create: EditingLEDEffectCreateWithoutUserInput
}

input EditingLEDEffectCreateOrConnectWithoutEditingLEDEffectInput {
  create: EditingLEDEffectCreateWithoutEditingLEDEffectInput!
  where: EditingLEDEffectWhereUniqueInput!
}

input EditingLEDEffectCreateOrConnectWithoutUserInput {
  create: EditingLEDEffectCreateWithoutUserInput!
  where: EditingLEDEffectWhereUniqueInput!
}

input EditingLEDEffectCreateWithoutEditingLEDEffectInput {
  user: UserCreateNestedOneWithoutEditingLEDEffectIdInput!
}

input EditingLEDEffectCreateWithoutUserInput {
  editingLEDEffect: LEDEffectCreateNestedOneWithoutEditingInput
}

input EditingLEDEffectOrderByWithRelationInput {
  LEDEffectId: SortOrder
  editingLEDEffect: LEDEffectOrderByWithRelationInput
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingLEDEffectRelationFilter {
  is: EditingLEDEffectWhereInput
  isNot: EditingLEDEffectWhereInput
}

input EditingLEDEffectUpdateOneWithoutEditingLEDEffectNestedInput {
  connect: EditingLEDEffectWhereUniqueInput
  connectOrCreate: EditingLEDEffectCreateOrConnectWithoutEditingLEDEffectInput
  create: EditingLEDEffectCreateWithoutEditingLEDEffectInput
  delete: Boolean
  disconnect: Boolean
  update: EditingLEDEffectUpdateWithoutEditingLEDEffectInput
  upsert: EditingLEDEffectUpsertWithoutEditingLEDEffectInput
}

input EditingLEDEffectUpdateOneWithoutUserNestedInput {
  connect: EditingLEDEffectWhereUniqueInput
  connectOrCreate: EditingLEDEffectCreateOrConnectWithoutUserInput
  create: EditingLEDEffectCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: EditingLEDEffectUpdateWithoutUserInput
  upsert: EditingLEDEffectUpsertWithoutUserInput
}

input EditingLEDEffectUpdateWithoutEditingLEDEffectInput {
  user: UserUpdateOneRequiredWithoutEditingLEDEffectIdNestedInput
}

input EditingLEDEffectUpdateWithoutUserInput {
  editingLEDEffect: LEDEffectUpdateOneWithoutEditingNestedInput
}

input EditingLEDEffectUpsertWithoutEditingLEDEffectInput {
  create: EditingLEDEffectCreateWithoutEditingLEDEffectInput!
  update: EditingLEDEffectUpdateWithoutEditingLEDEffectInput!
}

input EditingLEDEffectUpsertWithoutUserInput {
  create: EditingLEDEffectCreateWithoutUserInput!
  update: EditingLEDEffectUpdateWithoutUserInput!
}

input EditingLEDEffectWhereInput {
  AND: [EditingLEDEffectWhereInput!]
  LEDEffectId: IntNullableFilter
  NOT: [EditingLEDEffectWhereInput!]
  OR: [EditingLEDEffectWhereInput!]
  editingLEDEffect: LEDEffectRelationFilter
  user: UserRelationFilter
  userId: IntFilter
}

input EditingLEDEffectWhereUniqueInput {
  LEDEffectId: Int
  userId: Int
}

type EditingPositionFrame {
  editingFrame: PositionFrame
  frameId: Int
  user: User!
  userId: Int!
}

input EditingPositionFrameCreateNestedOneWithoutEditingFrameInput {
  connect: EditingPositionFrameWhereUniqueInput
  connectOrCreate: EditingPositionFrameCreateOrConnectWithoutEditingFrameInput
  create: EditingPositionFrameCreateWithoutEditingFrameInput
}

input EditingPositionFrameCreateNestedOneWithoutUserInput {
  connect: EditingPositionFrameWhereUniqueInput
  connectOrCreate: EditingPositionFrameCreateOrConnectWithoutUserInput
  create: EditingPositionFrameCreateWithoutUserInput
}

input EditingPositionFrameCreateOrConnectWithoutEditingFrameInput {
  create: EditingPositionFrameCreateWithoutEditingFrameInput!
  where: EditingPositionFrameWhereUniqueInput!
}

input EditingPositionFrameCreateOrConnectWithoutUserInput {
  create: EditingPositionFrameCreateWithoutUserInput!
  where: EditingPositionFrameWhereUniqueInput!
}

input EditingPositionFrameCreateWithoutEditingFrameInput {
  user: UserCreateNestedOneWithoutEditingPositionFrameIdInput!
}

input EditingPositionFrameCreateWithoutUserInput {
  editingFrame: PositionFrameCreateNestedOneWithoutEditingInput
}

input EditingPositionFrameOrderByWithRelationInput {
  editingFrame: PositionFrameOrderByWithRelationInput
  frameId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingPositionFrameRelationFilter {
  is: EditingPositionFrameWhereInput
  isNot: EditingPositionFrameWhereInput
}

input EditingPositionFrameUpdateOneWithoutEditingFrameNestedInput {
  connect: EditingPositionFrameWhereUniqueInput
  connectOrCreate: EditingPositionFrameCreateOrConnectWithoutEditingFrameInput
  create: EditingPositionFrameCreateWithoutEditingFrameInput
  delete: Boolean
  disconnect: Boolean
  update: EditingPositionFrameUpdateWithoutEditingFrameInput
  upsert: EditingPositionFrameUpsertWithoutEditingFrameInput
}

input EditingPositionFrameUpdateOneWithoutUserNestedInput {
  connect: EditingPositionFrameWhereUniqueInput
  connectOrCreate: EditingPositionFrameCreateOrConnectWithoutUserInput
  create: EditingPositionFrameCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: EditingPositionFrameUpdateWithoutUserInput
  upsert: EditingPositionFrameUpsertWithoutUserInput
}

input EditingPositionFrameUpdateWithoutEditingFrameInput {
  user: UserUpdateOneRequiredWithoutEditingPositionFrameIdNestedInput
}

input EditingPositionFrameUpdateWithoutUserInput {
  editingFrame: PositionFrameUpdateOneWithoutEditingNestedInput
}

input EditingPositionFrameUpsertWithoutEditingFrameInput {
  create: EditingPositionFrameCreateWithoutEditingFrameInput!
  update: EditingPositionFrameUpdateWithoutEditingFrameInput!
}

input EditingPositionFrameUpsertWithoutUserInput {
  create: EditingPositionFrameCreateWithoutUserInput!
  update: EditingPositionFrameUpdateWithoutUserInput!
}

input EditingPositionFrameWhereInput {
  AND: [EditingPositionFrameWhereInput!]
  NOT: [EditingPositionFrameWhereInput!]
  OR: [EditingPositionFrameWhereInput!]
  editingFrame: PositionFrameRelationFilter
  frameId: IntNullableFilter
  user: UserRelationFilter
  userId: IntFilter
}

input EditingPositionFrameWhereUniqueInput {
  frameId: Int
  userId: Int
}

type Effect {
  alpha: Float!
  colorCode: String!
}

type EffectListData {
  controlFrames: [JSON!]!
  dancerData: [JSON!]!
  description: String
  end: Int!
  id: Int!
  positionFrames: [JSON!]!
  start: Int!
}

type EffectListPayload {
  editBy: Int!
  effectListData: EffectListData
  effectListID: Int!
  mutation: String!
}

type EffectListResponse {
  msg: String
  ok: Boolean!
}

input EnumPartTypeFieldUpdateOperationsInput {
  set: PartType
}

input EnumPartTypeFilter {
  equals: PartType
  in: [PartType!]
  not: NestedEnumPartTypeFilter
  notIn: [PartType!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableListFilter {
  equals: [JSON!]
  has: JSON
  hasEvery: [JSON!]
  hasSome: [JSON!]
  isEmpty: Boolean
}

type LEDEffect {
  frames: [JSON!]!
  id: Int!
  name: String!
  partName: String!
  repeat: Int!
}

input LEDEffectCreateInput {
  editing: EditingLEDEffectCreateNestedOneWithoutEditingLEDEffectInput
  frames: LEDEffectCreateframesInput
  name: String!
  partName: String!
  repeat: Int!
}

input LEDEffectCreateNestedOneWithoutEditingInput {
  connect: LEDEffectWhereUniqueInput
  connectOrCreate: LEDEffectCreateOrConnectWithoutEditingInput
  create: LEDEffectCreateWithoutEditingInput
}

input LEDEffectCreateOrConnectWithoutEditingInput {
  create: LEDEffectCreateWithoutEditingInput!
  where: LEDEffectWhereUniqueInput!
}

input LEDEffectCreateWithoutEditingInput {
  frames: LEDEffectCreateframesInput
  name: String!
  partName: String!
  repeat: Int!
}

input LEDEffectCreateframesInput {
  set: [JSON!]!
}

input LEDEffectNamePartNameCompoundUniqueInput {
  name: String!
  partName: String!
}

input LEDEffectOrderByWithRelationInput {
  editing: EditingLEDEffectOrderByWithRelationInput
  frames: SortOrder
  id: SortOrder
  name: SortOrder
  partName: SortOrder
  repeat: SortOrder
}

input LEDEffectRelationFilter {
  is: LEDEffectWhereInput
  isNot: LEDEffectWhereInput
}

type LEDEffectResponse {
  effectName: String!
  effects: [LEDEffects!]!
  msg: String
  ok: Boolean!
  partName: String!
  repeat: Int!
}

input LEDEffectUpdateInput {
  editing: EditingLEDEffectUpdateOneWithoutEditingLEDEffectNestedInput
  frames: LEDEffectUpdateframesInput
  name: StringFieldUpdateOperationsInput
  partName: StringFieldUpdateOperationsInput
  repeat: IntFieldUpdateOperationsInput
}

input LEDEffectUpdateOneWithoutEditingNestedInput {
  connect: LEDEffectWhereUniqueInput
  connectOrCreate: LEDEffectCreateOrConnectWithoutEditingInput
  create: LEDEffectCreateWithoutEditingInput
  delete: Boolean
  disconnect: Boolean
  update: LEDEffectUpdateWithoutEditingInput
  upsert: LEDEffectUpsertWithoutEditingInput
}

input LEDEffectUpdateWithoutEditingInput {
  frames: LEDEffectUpdateframesInput
  name: StringFieldUpdateOperationsInput
  partName: StringFieldUpdateOperationsInput
  repeat: IntFieldUpdateOperationsInput
}

input LEDEffectUpdateframesInput {
  push: [JSON!]
  set: [JSON!]
}

input LEDEffectUpsertWithoutEditingInput {
  create: LEDEffectCreateWithoutEditingInput!
  update: LEDEffectUpdateWithoutEditingInput!
}

input LEDEffectWhereInput {
  AND: [LEDEffectWhereInput!]
  NOT: [LEDEffectWhereInput!]
  OR: [LEDEffectWhereInput!]
  editing: EditingLEDEffectRelationFilter
  frames: JsonNullableListFilter
  id: IntFilter
  name: StringFilter
  partName: StringFilter
  repeat: IntFilter
}

input LEDEffectWhereUniqueInput {
  id: Int
  name_partName: LEDEffectNamePartNameCompoundUniqueInput
}

type LEDEffects {
  effect: [Effect!]!
  fade: Boolean!
  start: Int!
}

type LEDMap {
  LEDMap: LEDMapCustomScalar!
}

"""LED map scalar type"""
scalar LEDMapCustomScalar

type LEDPayload {
  data: LEDEffect
  editBy: Float
  effectName: String
  mutation: String!
  partName: String
}

type Mutation {
  CancelEditControl(FrameID: Int!): RequestEditResponse!
  CancelEditLEDEffect(LEDEffectID: Int!): RequestEditResponse!
  CancelEditPosition(FrameID: Int!): RequestEditResponse!
  RequestEditControl(FrameID: Int!): RequestEditResponse!
  RequestEditLEDEffect(LEDEffectID: Int!): RequestEditResponse!
  RequestEditPosition(FrameID: Int!): RequestEditResponse!
  addColor(color: ColorCreateInput!): Color!
  addControlFrame(controlData: [[[String!]!]!], fade: Boolean = false, start: Int!): ControlFrame!
  addDancer(dancer: AddDancerInput!): DancerResponse!
  addEffectList(description: String, end: Int!, start: Int!): EffectListData!
  addLED(input: LEDEffectCreateInput!): LEDEffectResponse!
  addPart(part: AddPartInput!): PartResponse!
  addPositionFrame(positionData: [[Float!]!], start: Int!): PositionFrame!
  applyEffectList(id: Int!, start: Int!): EffectListResponse!
  deleteColor(color: String!): ColorResponse!
  deleteControlFrame(input: DeleteControlFrameInput!): ControlFrame!
  deleteDancer(dancer: deleteDancerInput!): DancerResponse!
  deleteEffectList(id: Int!): EffectListResponse!
  deleteLED(input: DeleteLEDInput!): DeleteLEDEffectResponse!
  deletePart(part: DeletePartInput!): PartResponse!
  deletePositionFrame(input: DeletePositionFrameInput!): PositionFrame!
  editColorCodeByColor(color: String!, colorCode: String!): Color!
  editControlFrame(input: EditControlFrameInput!): ControlFrame!
  editControlMap(input: EditControlMapInput!): ControlMap!
  editDancer(dancer: editDancerInput!): DancerResponse!
  editLED(input: LEDEffectCreateInput!): LEDEffectResponse!
  editPart(part: EditPartInput!): PartResponse!
  editPosMap(input: EditPositionMapInput!): PositionMap!
  editPositionFrame(input: EditPositionFrameInput!): PositionFrame!
  renameColor(newColor: String!, originalColor: String!): String!
  shift(end: Int!, move: Int!, shiftControl: Boolean!, shiftPosition: Boolean!, start: Int!): ShiftResponse!
  updateOneLEDEffect(data: LEDEffectUpdateInput!, where: LEDEffectWhereUniqueInput!): LEDEffect
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedEnumPartTypeFilter {
  equals: PartType
  in: [PartType!]
  not: NestedEnumPartTypeFilter
  notIn: [PartType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Part {
  _count: PartCount
  controlData(cursor: ControlDataWhereUniqueInput, distinct: [ControlDataScalarFieldEnum!], orderBy: [ControlDataOrderByWithRelationInput!], skip: Int, take: Int, where: ControlDataWhereInput): [ControlData!]!
  dancer: Dancer!
  dancerId: Int!
  id: Int!
  name: String!
  type: PartType!
}

type PartCount {
  controlData: Int!
}

input PartCreateManyDancerInput {
  id: Int
  name: String!
  type: PartType!
}

input PartCreateManyDancerInputEnvelope {
  data: [PartCreateManyDancerInput!]!
  skipDuplicates: Boolean
}

input PartCreateNestedManyWithoutDancerInput {
  connect: [PartWhereUniqueInput!]
  connectOrCreate: [PartCreateOrConnectWithoutDancerInput!]
  create: [PartCreateWithoutDancerInput!]
  createMany: PartCreateManyDancerInputEnvelope
}

input PartCreateNestedOneWithoutControlDataInput {
  connect: PartWhereUniqueInput
  connectOrCreate: PartCreateOrConnectWithoutControlDataInput
  create: PartCreateWithoutControlDataInput
}

input PartCreateOrConnectWithoutControlDataInput {
  create: PartCreateWithoutControlDataInput!
  where: PartWhereUniqueInput!
}

input PartCreateOrConnectWithoutDancerInput {
  create: PartCreateWithoutDancerInput!
  where: PartWhereUniqueInput!
}

input PartCreateWithoutControlDataInput {
  dancer: DancerCreateNestedOneWithoutPartsInput!
  name: String!
  type: PartType!
}

input PartCreateWithoutDancerInput {
  controlData: ControlDataCreateNestedManyWithoutPartInput
  name: String!
  type: PartType!
}

input PartListRelationFilter {
  every: PartWhereInput
  none: PartWhereInput
  some: PartWhereInput
}

input PartOrderByRelationAggregateInput {
  _count: SortOrder
}

input PartOrderByWithRelationInput {
  controlData: ControlDataOrderByRelationAggregateInput
  dancer: DancerOrderByWithRelationInput
  dancerId: SortOrder
  id: SortOrder
  name: SortOrder
  type: SortOrder
}

input PartRelationFilter {
  is: PartWhereInput
  isNot: PartWhereInput
}

type PartResponse {
  msg: String
  ok: Boolean!
  partData: Part
}

enum PartScalarFieldEnum {
  dancerId
  id
  name
  type
}

input PartScalarWhereInput {
  AND: [PartScalarWhereInput!]
  NOT: [PartScalarWhereInput!]
  OR: [PartScalarWhereInput!]
  dancerId: IntFilter
  id: IntFilter
  name: StringFilter
  type: EnumPartTypeFilter
}

enum PartType {
  FIBER
  LED
}

input PartUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  type: EnumPartTypeFieldUpdateOperationsInput
}

input PartUpdateManyWithWhereWithoutDancerInput {
  data: PartUpdateManyMutationInput!
  where: PartScalarWhereInput!
}

input PartUpdateManyWithoutDancerNestedInput {
  connect: [PartWhereUniqueInput!]
  connectOrCreate: [PartCreateOrConnectWithoutDancerInput!]
  create: [PartCreateWithoutDancerInput!]
  createMany: PartCreateManyDancerInputEnvelope
  delete: [PartWhereUniqueInput!]
  deleteMany: [PartScalarWhereInput!]
  disconnect: [PartWhereUniqueInput!]
  set: [PartWhereUniqueInput!]
  update: [PartUpdateWithWhereUniqueWithoutDancerInput!]
  updateMany: [PartUpdateManyWithWhereWithoutDancerInput!]
  upsert: [PartUpsertWithWhereUniqueWithoutDancerInput!]
}

input PartUpdateOneRequiredWithoutControlDataNestedInput {
  connect: PartWhereUniqueInput
  connectOrCreate: PartCreateOrConnectWithoutControlDataInput
  create: PartCreateWithoutControlDataInput
  update: PartUpdateWithoutControlDataInput
  upsert: PartUpsertWithoutControlDataInput
}

input PartUpdateWithWhereUniqueWithoutDancerInput {
  data: PartUpdateWithoutDancerInput!
  where: PartWhereUniqueInput!
}

input PartUpdateWithoutControlDataInput {
  dancer: DancerUpdateOneRequiredWithoutPartsNestedInput
  name: StringFieldUpdateOperationsInput
  type: EnumPartTypeFieldUpdateOperationsInput
}

input PartUpdateWithoutDancerInput {
  controlData: ControlDataUpdateManyWithoutPartNestedInput
  name: StringFieldUpdateOperationsInput
  type: EnumPartTypeFieldUpdateOperationsInput
}

input PartUpsertWithWhereUniqueWithoutDancerInput {
  create: PartCreateWithoutDancerInput!
  update: PartUpdateWithoutDancerInput!
  where: PartWhereUniqueInput!
}

input PartUpsertWithoutControlDataInput {
  create: PartCreateWithoutControlDataInput!
  update: PartUpdateWithoutControlDataInput!
}

input PartWhereInput {
  AND: [PartWhereInput!]
  NOT: [PartWhereInput!]
  OR: [PartWhereInput!]
  controlData: ControlDataListRelationFilter
  dancer: DancerRelationFilter
  dancerId: IntFilter
  id: IntFilter
  name: StringFilter
  type: EnumPartTypeFilter
}

input PartWhereUniqueInput {
  id: Int
}

"""Mongo object id scalar type"""
scalar PosMapMutationObjectId

type PositionData {
  dancer: Dancer!
  dancerId: Int!
  frame: PositionFrame!
  frameId: Int!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataCreateManyDancerInput {
  frameId: Int!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataCreateManyDancerInputEnvelope {
  data: [PositionDataCreateManyDancerInput!]!
  skipDuplicates: Boolean
}

input PositionDataCreateManyFrameInput {
  dancerId: Int!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataCreateManyFrameInputEnvelope {
  data: [PositionDataCreateManyFrameInput!]!
  skipDuplicates: Boolean
}

input PositionDataCreateNestedManyWithoutDancerInput {
  connect: [PositionDataWhereUniqueInput!]
  connectOrCreate: [PositionDataCreateOrConnectWithoutDancerInput!]
  create: [PositionDataCreateWithoutDancerInput!]
  createMany: PositionDataCreateManyDancerInputEnvelope
}

input PositionDataCreateNestedManyWithoutFrameInput {
  connect: [PositionDataWhereUniqueInput!]
  connectOrCreate: [PositionDataCreateOrConnectWithoutFrameInput!]
  create: [PositionDataCreateWithoutFrameInput!]
  createMany: PositionDataCreateManyFrameInputEnvelope
}

input PositionDataCreateOrConnectWithoutDancerInput {
  create: PositionDataCreateWithoutDancerInput!
  where: PositionDataWhereUniqueInput!
}

input PositionDataCreateOrConnectWithoutFrameInput {
  create: PositionDataCreateWithoutFrameInput!
  where: PositionDataWhereUniqueInput!
}

input PositionDataCreateWithoutDancerInput {
  frame: PositionFrameCreateNestedOneWithoutPositionDatasInput!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataCreateWithoutFrameInput {
  dancer: DancerCreateNestedOneWithoutPositionDataInput!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataDancerIdFrameIdCompoundUniqueInput {
  dancerId: Int!
  frameId: Int!
}

input PositionDataListRelationFilter {
  every: PositionDataWhereInput
  none: PositionDataWhereInput
  some: PositionDataWhereInput
}

input PositionDataOrderByRelationAggregateInput {
  _count: SortOrder
}

input PositionDataOrderByWithRelationInput {
  dancer: DancerOrderByWithRelationInput
  dancerId: SortOrder
  frame: PositionFrameOrderByWithRelationInput
  frameId: SortOrder
  x: SortOrder
  y: SortOrder
  z: SortOrder
}

enum PositionDataScalarFieldEnum {
  dancerId
  frameId
  x
  y
  z
}

input PositionDataScalarWhereInput {
  AND: [PositionDataScalarWhereInput!]
  NOT: [PositionDataScalarWhereInput!]
  OR: [PositionDataScalarWhereInput!]
  dancerId: IntFilter
  frameId: IntFilter
  x: FloatFilter
  y: FloatFilter
  z: FloatFilter
}

input PositionDataUpdateManyMutationInput {
  x: FloatFieldUpdateOperationsInput
  y: FloatFieldUpdateOperationsInput
  z: FloatFieldUpdateOperationsInput
}

input PositionDataUpdateManyWithWhereWithoutDancerInput {
  data: PositionDataUpdateManyMutationInput!
  where: PositionDataScalarWhereInput!
}

input PositionDataUpdateManyWithWhereWithoutFrameInput {
  data: PositionDataUpdateManyMutationInput!
  where: PositionDataScalarWhereInput!
}

input PositionDataUpdateManyWithoutDancerNestedInput {
  connect: [PositionDataWhereUniqueInput!]
  connectOrCreate: [PositionDataCreateOrConnectWithoutDancerInput!]
  create: [PositionDataCreateWithoutDancerInput!]
  createMany: PositionDataCreateManyDancerInputEnvelope
  delete: [PositionDataWhereUniqueInput!]
  deleteMany: [PositionDataScalarWhereInput!]
  disconnect: [PositionDataWhereUniqueInput!]
  set: [PositionDataWhereUniqueInput!]
  update: [PositionDataUpdateWithWhereUniqueWithoutDancerInput!]
  updateMany: [PositionDataUpdateManyWithWhereWithoutDancerInput!]
  upsert: [PositionDataUpsertWithWhereUniqueWithoutDancerInput!]
}

input PositionDataUpdateManyWithoutFrameNestedInput {
  connect: [PositionDataWhereUniqueInput!]
  connectOrCreate: [PositionDataCreateOrConnectWithoutFrameInput!]
  create: [PositionDataCreateWithoutFrameInput!]
  createMany: PositionDataCreateManyFrameInputEnvelope
  delete: [PositionDataWhereUniqueInput!]
  deleteMany: [PositionDataScalarWhereInput!]
  disconnect: [PositionDataWhereUniqueInput!]
  set: [PositionDataWhereUniqueInput!]
  update: [PositionDataUpdateWithWhereUniqueWithoutFrameInput!]
  updateMany: [PositionDataUpdateManyWithWhereWithoutFrameInput!]
  upsert: [PositionDataUpsertWithWhereUniqueWithoutFrameInput!]
}

input PositionDataUpdateWithWhereUniqueWithoutDancerInput {
  data: PositionDataUpdateWithoutDancerInput!
  where: PositionDataWhereUniqueInput!
}

input PositionDataUpdateWithWhereUniqueWithoutFrameInput {
  data: PositionDataUpdateWithoutFrameInput!
  where: PositionDataWhereUniqueInput!
}

input PositionDataUpdateWithoutDancerInput {
  frame: PositionFrameUpdateOneRequiredWithoutPositionDatasNestedInput
  x: FloatFieldUpdateOperationsInput
  y: FloatFieldUpdateOperationsInput
  z: FloatFieldUpdateOperationsInput
}

input PositionDataUpdateWithoutFrameInput {
  dancer: DancerUpdateOneRequiredWithoutPositionDataNestedInput
  x: FloatFieldUpdateOperationsInput
  y: FloatFieldUpdateOperationsInput
  z: FloatFieldUpdateOperationsInput
}

input PositionDataUpsertWithWhereUniqueWithoutDancerInput {
  create: PositionDataCreateWithoutDancerInput!
  update: PositionDataUpdateWithoutDancerInput!
  where: PositionDataWhereUniqueInput!
}

input PositionDataUpsertWithWhereUniqueWithoutFrameInput {
  create: PositionDataCreateWithoutFrameInput!
  update: PositionDataUpdateWithoutFrameInput!
  where: PositionDataWhereUniqueInput!
}

input PositionDataWhereInput {
  AND: [PositionDataWhereInput!]
  NOT: [PositionDataWhereInput!]
  OR: [PositionDataWhereInput!]
  dancer: DancerRelationFilter
  dancerId: IntFilter
  frame: PositionFrameRelationFilter
  frameId: IntFilter
  x: FloatFilter
  y: FloatFilter
  z: FloatFilter
}

input PositionDataWhereUniqueInput {
  dancerId_frameId: PositionDataDancerIdFrameIdCompoundUniqueInput
}

type PositionFrame {
  _count: PositionFrameCount
  editing: EditingPositionFrame
  id: Int!
  positionDatas(cursor: PositionDataWhereUniqueInput, distinct: [PositionDataScalarFieldEnum!], orderBy: [PositionDataOrderByWithRelationInput!], skip: Int, take: Int, where: PositionDataWhereInput): [PositionData!]!
  start: Int!
}

type PositionFrameCount {
  positionDatas: Int!
}

input PositionFrameCreateNestedOneWithoutEditingInput {
  connect: PositionFrameWhereUniqueInput
  connectOrCreate: PositionFrameCreateOrConnectWithoutEditingInput
  create: PositionFrameCreateWithoutEditingInput
}

input PositionFrameCreateNestedOneWithoutPositionDatasInput {
  connect: PositionFrameWhereUniqueInput
  connectOrCreate: PositionFrameCreateOrConnectWithoutPositionDatasInput
  create: PositionFrameCreateWithoutPositionDatasInput
}

input PositionFrameCreateOrConnectWithoutEditingInput {
  create: PositionFrameCreateWithoutEditingInput!
  where: PositionFrameWhereUniqueInput!
}

input PositionFrameCreateOrConnectWithoutPositionDatasInput {
  create: PositionFrameCreateWithoutPositionDatasInput!
  where: PositionFrameWhereUniqueInput!
}

input PositionFrameCreateWithoutEditingInput {
  positionDatas: PositionDataCreateNestedManyWithoutFrameInput
  start: Int!
}

input PositionFrameCreateWithoutPositionDatasInput {
  editing: EditingPositionFrameCreateNestedOneWithoutEditingFrameInput
  start: Int!
}

input PositionFrameOrderByWithRelationInput {
  editing: EditingPositionFrameOrderByWithRelationInput
  id: SortOrder
  positionDatas: PositionDataOrderByRelationAggregateInput
  start: SortOrder
}

input PositionFrameRelationFilter {
  is: PositionFrameWhereInput
  isNot: PositionFrameWhereInput
}

input PositionFrameUpdateOneRequiredWithoutPositionDatasNestedInput {
  connect: PositionFrameWhereUniqueInput
  connectOrCreate: PositionFrameCreateOrConnectWithoutPositionDatasInput
  create: PositionFrameCreateWithoutPositionDatasInput
  update: PositionFrameUpdateWithoutPositionDatasInput
  upsert: PositionFrameUpsertWithoutPositionDatasInput
}

input PositionFrameUpdateOneWithoutEditingNestedInput {
  connect: PositionFrameWhereUniqueInput
  connectOrCreate: PositionFrameCreateOrConnectWithoutEditingInput
  create: PositionFrameCreateWithoutEditingInput
  delete: Boolean
  disconnect: Boolean
  update: PositionFrameUpdateWithoutEditingInput
  upsert: PositionFrameUpsertWithoutEditingInput
}

input PositionFrameUpdateWithoutEditingInput {
  positionDatas: PositionDataUpdateManyWithoutFrameNestedInput
  start: IntFieldUpdateOperationsInput
}

input PositionFrameUpdateWithoutPositionDatasInput {
  editing: EditingPositionFrameUpdateOneWithoutEditingFrameNestedInput
  start: IntFieldUpdateOperationsInput
}

input PositionFrameUpsertWithoutEditingInput {
  create: PositionFrameCreateWithoutEditingInput!
  update: PositionFrameUpdateWithoutEditingInput!
}

input PositionFrameUpsertWithoutPositionDatasInput {
  create: PositionFrameCreateWithoutPositionDatasInput!
  update: PositionFrameUpdateWithoutPositionDatasInput!
}

input PositionFrameWhereInput {
  AND: [PositionFrameWhereInput!]
  NOT: [PositionFrameWhereInput!]
  OR: [PositionFrameWhereInput!]
  editing: EditingPositionFrameRelationFilter
  id: IntFilter
  positionDatas: PositionDataListRelationFilter
  start: IntFilter
}

input PositionFrameWhereUniqueInput {
  id: Int
  start: Int
}

type PositionMap {
  frameIds: PositionMapQueryObjectId!
}

type PositionMapPayload {
  editBy: Int!
  frame: PosMapMutationObjectId!
}

"""Mongo object id scalar type"""
scalar PositionMapQueryObjectId

type PositionRecordPayload {
  addID: [Int!]!
  deleteID: [Int!]!
  editBy: Int!
  index: Int!
  mutation: String!
  updateID: [Int!]!
}

type Query {
  ControlMap(select: queryMapInput): ControlMap!
  LEDMap: LEDMap!
  PosMap(select: queryMapInput): PositionMap!
  color(where: ColorWhereUniqueInput!): Color
  colorMap: ColorMap!
  colors(cursor: ColorWhereUniqueInput, distinct: [ColorScalarFieldEnum!], orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): [Color!]!
  controlFrame(frameID: Int!): ControlFrame!
  controlFrameIDs: [Int!]!
  dancer(dancerName: String!): Dancer!
  dancers: [Dancer!]!
  effectList: [EffectListData!]!
  positionFrame(frameID: Int!): PositionFrame!
  positionFrameIDs: [Int!]!
}

enum QueryMode {
  default
  insensitive
}

type RequestEditResponse {
  editing: Int
  ok: Boolean!
}

type ShiftResponse {
  msg: String
  ok: Boolean!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  DancerSubscription: DancerPayload!
  colorSubscription: ColorPayload!
  controlMapSubscription: ControlMapPayload!
  controlRecordSubscription: ControlRecordPayload!
  effectListSubscription: EffectListPayload!
  ledRecordSubscription: LEDPayload!
  positionMapSubscription: PositionMapPayload!
  positionRecordSubscription: PositionRecordPayload!
}

type User {
  editingControlFrameId: EditingControlFrame
  editingLEDEffectId: EditingLEDEffect
  editingPositionFrameId: EditingPositionFrame
  id: Int!
  name: String!
  password: String!
}

input UserCreateNestedOneWithoutEditingControlFrameIdInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEditingControlFrameIdInput
  create: UserCreateWithoutEditingControlFrameIdInput
}

input UserCreateNestedOneWithoutEditingLEDEffectIdInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEditingLEDEffectIdInput
  create: UserCreateWithoutEditingLEDEffectIdInput
}

input UserCreateNestedOneWithoutEditingPositionFrameIdInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEditingPositionFrameIdInput
  create: UserCreateWithoutEditingPositionFrameIdInput
}

input UserCreateOrConnectWithoutEditingControlFrameIdInput {
  create: UserCreateWithoutEditingControlFrameIdInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutEditingLEDEffectIdInput {
  create: UserCreateWithoutEditingLEDEffectIdInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutEditingPositionFrameIdInput {
  create: UserCreateWithoutEditingPositionFrameIdInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutEditingControlFrameIdInput {
  editingLEDEffectId: EditingLEDEffectCreateNestedOneWithoutUserInput
  editingPositionFrameId: EditingPositionFrameCreateNestedOneWithoutUserInput
  name: String!
  password: String!
}

input UserCreateWithoutEditingLEDEffectIdInput {
  editingControlFrameId: EditingControlFrameCreateNestedOneWithoutUserInput
  editingPositionFrameId: EditingPositionFrameCreateNestedOneWithoutUserInput
  name: String!
  password: String!
}

input UserCreateWithoutEditingPositionFrameIdInput {
  editingControlFrameId: EditingControlFrameCreateNestedOneWithoutUserInput
  editingLEDEffectId: EditingLEDEffectCreateNestedOneWithoutUserInput
  name: String!
  password: String!
}

input UserOrderByWithRelationInput {
  editingControlFrameId: EditingControlFrameOrderByWithRelationInput
  editingLEDEffectId: EditingLEDEffectOrderByWithRelationInput
  editingPositionFrameId: EditingPositionFrameOrderByWithRelationInput
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserUpdateOneRequiredWithoutEditingControlFrameIdNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEditingControlFrameIdInput
  create: UserCreateWithoutEditingControlFrameIdInput
  update: UserUpdateWithoutEditingControlFrameIdInput
  upsert: UserUpsertWithoutEditingControlFrameIdInput
}

input UserUpdateOneRequiredWithoutEditingLEDEffectIdNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEditingLEDEffectIdInput
  create: UserCreateWithoutEditingLEDEffectIdInput
  update: UserUpdateWithoutEditingLEDEffectIdInput
  upsert: UserUpsertWithoutEditingLEDEffectIdInput
}

input UserUpdateOneRequiredWithoutEditingPositionFrameIdNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutEditingPositionFrameIdInput
  create: UserCreateWithoutEditingPositionFrameIdInput
  update: UserUpdateWithoutEditingPositionFrameIdInput
  upsert: UserUpsertWithoutEditingPositionFrameIdInput
}

input UserUpdateWithoutEditingControlFrameIdInput {
  editingLEDEffectId: EditingLEDEffectUpdateOneWithoutUserNestedInput
  editingPositionFrameId: EditingPositionFrameUpdateOneWithoutUserNestedInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutEditingLEDEffectIdInput {
  editingControlFrameId: EditingControlFrameUpdateOneWithoutUserNestedInput
  editingPositionFrameId: EditingPositionFrameUpdateOneWithoutUserNestedInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutEditingPositionFrameIdInput {
  editingControlFrameId: EditingControlFrameUpdateOneWithoutUserNestedInput
  editingLEDEffectId: EditingLEDEffectUpdateOneWithoutUserNestedInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutEditingControlFrameIdInput {
  create: UserCreateWithoutEditingControlFrameIdInput!
  update: UserUpdateWithoutEditingControlFrameIdInput!
}

input UserUpsertWithoutEditingLEDEffectIdInput {
  create: UserCreateWithoutEditingLEDEffectIdInput!
  update: UserUpdateWithoutEditingLEDEffectIdInput!
}

input UserUpsertWithoutEditingPositionFrameIdInput {
  create: UserCreateWithoutEditingPositionFrameIdInput!
  update: UserUpdateWithoutEditingPositionFrameIdInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  editingControlFrameId: EditingControlFrameRelationFilter
  editingLEDEffectId: EditingLEDEffectRelationFilter
  editingPositionFrameId: EditingPositionFrameRelationFilter
  id: IntFilter
  name: StringFilter
  password: StringFilter
}

input UserWhereUniqueInput {
  id: Int
  name: String
}

enum dancerMutation {
  CREATED
  DELETED
  UPDATED
}

input deleteDancerInput {
  id: Int!
}

input editDancerInput {
  id: Int!
  name: String!
}

input queryMapInput {
  frameIds: [Int!]!
}
