# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddDancerInput {
  name: String!
}

input AddPartInput {
  dancerName: String!
  name: String!
  type: String!
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Color {
  color: String!
  colorCode: String!
}

input ColorOrderByWithRelationInput {
  color: SortOrder
  colorCode: SortOrder
}

enum ColorScalarFieldEnum {
  color
  colorCode
}

input ColorWhereInput {
  AND: [ColorWhereInput!]
  color: StringFilter
  colorCode: StringFilter
  NOT: [ColorWhereInput!]
  OR: [ColorWhereInput!]
}

input ColorWhereUniqueInput {
  color: String
  colorCode: String
}

type ControlData {
  frame: ControlFrame!
  frameId: Int!
  part: Part!
  partId: Int!
  value: JSON!
}

input ControlDataInput {
  alpha: Float
  color: String
  ELValue: Float
  partName: String!
  src: String
}

input ControlDataListRelationFilter {
  every: ControlDataWhereInput
  none: ControlDataWhereInput
  some: ControlDataWhereInput
}

input ControlDataOrderByRelationAggregateInput {
  _count: SortOrder
}

input ControlDataOrderByWithRelationInput {
  frame: ControlFrameOrderByWithRelationInput
  frameId: SortOrder
  part: PartOrderByWithRelationInput
  partId: SortOrder
  value: SortOrder
}

input ControlDataPartIdFrameIdCompoundUniqueInput {
  frameId: Int!
  partId: Int!
}

enum ControlDataScalarFieldEnum {
  frameId
  partId
  value
}

input ControlDataWhereInput {
  AND: [ControlDataWhereInput!]
  frame: ControlFrameRelationFilter
  frameId: IntFilter
  NOT: [ControlDataWhereInput!]
  OR: [ControlDataWhereInput!]
  part: PartRelationFilter
  partId: IntFilter
  value: JsonFilter
}

input ControlDataWhereUniqueInput {
  partId_frameId: ControlDataPartIdFrameIdCompoundUniqueInput
}

type ControlFrame {
  _count: ControlFrameCount
  controlDatas(cursor: ControlDataWhereUniqueInput, distinct: [ControlDataScalarFieldEnum!], orderBy: [ControlDataOrderByWithRelationInput!], skip: Int, take: Int, where: ControlDataWhereInput): [ControlData!]!
  editing: EditingControlFrame
  fade: Boolean!
  id: Int!
  start: Int!
}

type ControlFrameCount {
  controlDatas: Int!
}

input ControlFrameOrderByWithRelationInput {
  controlDatas: ControlDataOrderByRelationAggregateInput
  editing: EditingControlFrameOrderByWithRelationInput
  fade: SortOrder
  id: SortOrder
  start: SortOrder
}

input ControlFrameRelationFilter {
  is: ControlFrameWhereInput
  isNot: ControlFrameWhereInput
}

input ControlFrameWhereInput {
  AND: [ControlFrameWhereInput!]
  controlDatas: ControlDataListRelationFilter
  editing: EditingControlFrameRelationFilter
  fade: BoolFilter
  id: IntFilter
  NOT: [ControlFrameWhereInput!]
  OR: [ControlFrameWhereInput!]
  start: IntFilter
}

type Dancer {
  _count: DancerCount
  id: Int!
  name: String!
  parts(cursor: PartWhereUniqueInput, distinct: [PartScalarFieldEnum!], orderBy: [PartOrderByWithRelationInput!], skip: Int, take: Int, where: PartWhereInput): [Part!]!
  positionData(cursor: PositionDataWhereUniqueInput, distinct: [PositionDataScalarFieldEnum!], orderBy: [PositionDataOrderByWithRelationInput!], skip: Int, take: Int, where: PositionDataWhereInput): [PositionData!]!
}

type DancerCount {
  parts: Int!
  positionData: Int!
}

input DancerOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  parts: PartOrderByRelationAggregateInput
  positionData: PositionDataOrderByRelationAggregateInput
}

input DancerRelationFilter {
  is: DancerWhereInput
  isNot: DancerWhereInput
}

type DancerResponse {
  dancerData: Dancer
  msg: String
  ok: Boolean!
}

input DancerWhereInput {
  AND: [DancerWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [DancerWhereInput!]
  OR: [DancerWhereInput!]
  parts: PartListRelationFilter
  positionData: PositionDataListRelationFilter
}

input DeleteControlFrameInput {
  frameID: Float!
}

input deleteDancerInput {
  id: Float!
}

input DeletePartInput {
  dancerName: String!
  id: Float!
}

input DeletePositionFrameInput {
  frameID: Float!
}

input EditControlFrameInput {
  fade: Boolean
  frameID: Float!
  start: Float
}

input EditControlInput {
  controlData: [ControlDataInput!]!
  dancerName: String!
}

input editDancerInput {
  id: Float!
  name: String!
}

type EditingControlFrame {
  editingFrame: ControlFrame
  frameId: Int
  user: User!
  userId: Int!
}

input EditingControlFrameOrderByWithRelationInput {
  editingFrame: ControlFrameOrderByWithRelationInput
  frameId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingControlFrameRelationFilter {
  is: EditingControlFrameWhereInput
  isNot: EditingControlFrameWhereInput
}

input EditingControlFrameWhereInput {
  AND: [EditingControlFrameWhereInput!]
  editingFrame: ControlFrameRelationFilter
  frameId: IntNullableFilter
  NOT: [EditingControlFrameWhereInput!]
  OR: [EditingControlFrameWhereInput!]
  user: UserRelationFilter
  userId: IntFilter
}

type EditingPositionFrame {
  editingFrame: PositionFrame
  frameId: Int
  user: User!
  userId: Int!
}

input EditingPositionFrameOrderByWithRelationInput {
  editingFrame: PositionFrameOrderByWithRelationInput
  frameId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingPositionFrameRelationFilter {
  is: EditingPositionFrameWhereInput
  isNot: EditingPositionFrameWhereInput
}

input EditingPositionFrameWhereInput {
  AND: [EditingPositionFrameWhereInput!]
  editingFrame: PositionFrameRelationFilter
  frameId: IntNullableFilter
  NOT: [EditingPositionFrameWhereInput!]
  OR: [EditingPositionFrameWhereInput!]
  user: UserRelationFilter
  userId: IntFilter
}

input EditPartInput {
  dancerName: String!
  id: Float!
  name: String!
  type: String!
}

input EditPositionFrameInput {
  frameID: Float!
  start: Float!
}

input EditPositionInput {
  dancerName: String!
  positionData: PositionDataInput!
}

input EnumPartTypeFilter {
  equals: PartType
  in: [PartType!]
  not: NestedEnumPartTypeFilter
  notIn: [PartType!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Map {
  frames: MapQueryObjectId!
}

"""Mongo object id scalar type"""
scalar MapQueryObjectId

type Mutation {
  addControlFrame(fade: Boolean = false, start: Float!): ControlFrame!
  addDancer(dancer: AddDancerInput!): DancerResponse!
  addPart(part: AddPartInput!): PartResponse!
  addPositionFrame(start: Float!): PositionFrame!
  CancelEditControl(FrameID: String!): RequestEditResponse!
  CancelEditPosition(FrameID: String!): RequestEditResponse!
  deleteControlFrame(input: DeleteControlFrameInput!): ControlFrame!
  deleteDancer(dancer: deleteDancerInput!): DancerResponse!
  deletePart(part: DeletePartInput!): PartResponse!
  deletePositionFrame(input: DeletePositionFrameInput!): PositionFrame!
  editControlFrame(input: EditControlFrameInput!): ControlFrame!
  editControlMap(controlData: [EditControlInput!]!, fade: Boolean = false, start: Float!): ControlData!
  editDancer(dancer: editDancerInput!): DancerResponse!
  editPart(part: EditPartInput!): PartResponse!
  editPositionFrame(input: EditPositionFrameInput!): PositionFrame!
  editPosMap(positionData: [EditPositionInput!]!, start: Float!): Map!
  RequestEditControl(FrameID: String!): RequestEditResponse!
  RequestEditPosition(FrameID: String!): RequestEditResponse!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedEnumPartTypeFilter {
  equals: PartType
  in: [PartType!]
  not: NestedEnumPartTypeFilter
  notIn: [PartType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Part {
  _count: PartCount
  controlData(cursor: ControlDataWhereUniqueInput, distinct: [ControlDataScalarFieldEnum!], orderBy: [ControlDataOrderByWithRelationInput!], skip: Int, take: Int, where: ControlDataWhereInput): [ControlData!]!
  dancer: Dancer!
  dancerId: Int!
  id: Int!
  name: String!
  type: PartType!
}

type PartCount {
  controlData: Int!
}

input PartListRelationFilter {
  every: PartWhereInput
  none: PartWhereInput
  some: PartWhereInput
}

input PartOrderByRelationAggregateInput {
  _count: SortOrder
}

input PartOrderByWithRelationInput {
  controlData: ControlDataOrderByRelationAggregateInput
  dancer: DancerOrderByWithRelationInput
  dancerId: SortOrder
  id: SortOrder
  name: SortOrder
  type: SortOrder
}

input PartRelationFilter {
  is: PartWhereInput
  isNot: PartWhereInput
}

type PartResponse {
  msg: String
  ok: Boolean!
  partData: Part
}

enum PartScalarFieldEnum {
  dancerId
  id
  name
  type
}

enum PartType {
  FIBER
  LED
}

input PartWhereInput {
  AND: [PartWhereInput!]
  controlData: ControlDataListRelationFilter
  dancer: DancerRelationFilter
  dancerId: IntFilter
  id: IntFilter
  name: StringFilter
  NOT: [PartWhereInput!]
  OR: [PartWhereInput!]
  type: EnumPartTypeFilter
}

input PartWhereUniqueInput {
  id: Int
}

type PositionData {
  dancer: Dancer!
  dancerId: Int!
  frame: PositionFrame!
  frameId: Int!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataDancerIdFrameIdCompoundUniqueInput {
  dancerId: Int!
  frameId: Int!
}

input PositionDataInput {
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataListRelationFilter {
  every: PositionDataWhereInput
  none: PositionDataWhereInput
  some: PositionDataWhereInput
}

input PositionDataOrderByRelationAggregateInput {
  _count: SortOrder
}

input PositionDataOrderByWithRelationInput {
  dancer: DancerOrderByWithRelationInput
  dancerId: SortOrder
  frame: PositionFrameOrderByWithRelationInput
  frameId: SortOrder
  x: SortOrder
  y: SortOrder
  z: SortOrder
}

enum PositionDataScalarFieldEnum {
  dancerId
  frameId
  x
  y
  z
}

input PositionDataWhereInput {
  AND: [PositionDataWhereInput!]
  dancer: DancerRelationFilter
  dancerId: IntFilter
  frame: PositionFrameRelationFilter
  frameId: IntFilter
  NOT: [PositionDataWhereInput!]
  OR: [PositionDataWhereInput!]
  x: FloatFilter
  y: FloatFilter
  z: FloatFilter
}

input PositionDataWhereUniqueInput {
  dancerId_frameId: PositionDataDancerIdFrameIdCompoundUniqueInput
}

type PositionFrame {
  _count: PositionFrameCount
  editing: EditingPositionFrame
  id: Int!
  positionDatas(cursor: PositionDataWhereUniqueInput, distinct: [PositionDataScalarFieldEnum!], orderBy: [PositionDataOrderByWithRelationInput!], skip: Int, take: Int, where: PositionDataWhereInput): [PositionData!]!
  start: Int!
}

type PositionFrameCount {
  positionDatas: Int!
}

input PositionFrameOrderByWithRelationInput {
  editing: EditingPositionFrameOrderByWithRelationInput
  id: SortOrder
  positionDatas: PositionDataOrderByRelationAggregateInput
  start: SortOrder
}

input PositionFrameRelationFilter {
  is: PositionFrameWhereInput
  isNot: PositionFrameWhereInput
}

input PositionFrameWhereInput {
  AND: [PositionFrameWhereInput!]
  editing: EditingPositionFrameRelationFilter
  id: IntFilter
  NOT: [PositionFrameWhereInput!]
  OR: [PositionFrameWhereInput!]
  positionDatas: PositionDataListRelationFilter
  start: IntFilter
}

type Query {
  color(where: ColorWhereUniqueInput!): Color
  colors(cursor: ColorWhereUniqueInput, distinct: [ColorScalarFieldEnum!], orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): [Color!]!
  controlFrame(frameID: Float!): ControlFrame!
  controlFrameIDs: [ID!]!
  ControlMap: Map!
  dancer(dancerName: String!): Dancer!
  dancers: [Dancer!]!
  positionFrame(start: Float!): PositionFrame!
  positionFrameIDs: [ID!]!
  PosMap: Map!
}

enum QueryMode {
  default
  insensitive
}

type RequestEditResponse {
  editing: String
  ok: Boolean!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type User {
  editingControlFrameId: EditingControlFrame
  editingPositionFrameId: EditingPositionFrame
  id: Int!
  name: String!
  password: String!
}

input UserOrderByWithRelationInput {
  editingControlFrameId: EditingControlFrameOrderByWithRelationInput
  editingPositionFrameId: EditingPositionFrameOrderByWithRelationInput
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  editingControlFrameId: EditingControlFrameRelationFilter
  editingPositionFrameId: EditingPositionFrameRelationFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
}
