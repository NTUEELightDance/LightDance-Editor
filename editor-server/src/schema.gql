# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddDancerInput {
  name: String!
}

input AddPartInput {
  dancerName: String!
  name: String!
  type: String!
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Color {
  color: String!
  colorCode: String!
}

input ColorCreateInput {
  color: String!
  colorCode: String!
}

type ColorMap {
  colorMap: ColorMapCustomScalar!
}

"""Color map scalar type"""
scalar ColorMapCustomScalar

input ColorOrderByWithRelationInput {
  color: SortOrder
  colorCode: SortOrder
}

type ColorPayload {
  color: String!
  colorCode: String
  editBy: Float!
  mutation: String!
  renameColor: String
}

type ColorResponse {
  color: String!
  colorCode: String!
  msg: String
  ok: Boolean
}

enum ColorScalarFieldEnum {
  color
  colorCode
}

input ColorWhereInput {
  AND: [ColorWhereInput!]
  color: StringFilter
  colorCode: StringFilter
  NOT: [ColorWhereInput!]
  OR: [ColorWhereInput!]
}

input ColorWhereUniqueInput {
  color: String
}

type ControlData {
  frame: ControlFrame!
  frameId: Int!
  part: Part!
  partId: Int!
  value: JSON!
}

input ControlDataListRelationFilter {
  every: ControlDataWhereInput
  none: ControlDataWhereInput
  some: ControlDataWhereInput
}

input ControlDataOrderByRelationAggregateInput {
  _count: SortOrder
}

input ControlDataOrderByWithRelationInput {
  frame: ControlFrameOrderByWithRelationInput
  frameId: SortOrder
  part: PartOrderByWithRelationInput
  partId: SortOrder
  value: SortOrder
}

input ControlDataPartIdFrameIdCompoundUniqueInput {
  frameId: Int!
  partId: Int!
}

enum ControlDataScalarFieldEnum {
  frameId
  partId
  value
}

input ControlDataWhereInput {
  AND: [ControlDataWhereInput!]
  frame: ControlFrameRelationFilter
  frameId: IntFilter
  NOT: [ControlDataWhereInput!]
  OR: [ControlDataWhereInput!]
  part: PartRelationFilter
  partId: IntFilter
  value: JsonFilter
}

input ControlDataWhereUniqueInput {
  partId_frameId: ControlDataPartIdFrameIdCompoundUniqueInput
}

type ControlFrame {
  _count: ControlFrameCount
  controlDatas(cursor: ControlDataWhereUniqueInput, distinct: [ControlDataScalarFieldEnum!], orderBy: [ControlDataOrderByWithRelationInput!], skip: Int, take: Int, where: ControlDataWhereInput): [ControlData!]!
  editing: EditingControlFrame
  fade: Boolean!
  id: Int!
  start: Int!
}

type ControlFrameCount {
  controlDatas: Int!
}

input ControlFrameOrderByWithRelationInput {
  controlDatas: ControlDataOrderByRelationAggregateInput
  editing: EditingControlFrameOrderByWithRelationInput
  fade: SortOrder
  id: SortOrder
  start: SortOrder
}

input ControlFrameRelationFilter {
  is: ControlFrameWhereInput
  isNot: ControlFrameWhereInput
}

input ControlFrameWhereInput {
  AND: [ControlFrameWhereInput!]
  controlDatas: ControlDataListRelationFilter
  editing: EditingControlFrameRelationFilter
  fade: BoolFilter
  id: IntFilter
  NOT: [ControlFrameWhereInput!]
  OR: [ControlFrameWhereInput!]
  start: IntFilter
}

type ControlMap {
  frameIds: ControlMapQueryObjectId!
}

"""Mongo object id scalar type"""
scalar ControlMapMutationObjectId

type ControlMapPayload {
  editBy: Float!
  frame: ControlMapMutationObjectId!
}

"""Mongo object id scalar type"""
scalar ControlMapQueryObjectId

type ControlRecordPayload {
  addID: [String!]!
  deleteID: [String!]!
  editBy: Float!
  index: Int!
  mutation: String!
  updateID: [String!]!
}

type Dancer {
  _count: DancerCount
  id: Int!
  name: String!
  parts(cursor: PartWhereUniqueInput, distinct: [PartScalarFieldEnum!], orderBy: [PartOrderByWithRelationInput!], skip: Int, take: Int, where: PartWhereInput): [Part!]!
  positionData(cursor: PositionDataWhereUniqueInput, distinct: [PositionDataScalarFieldEnum!], orderBy: [PositionDataOrderByWithRelationInput!], skip: Int, take: Int, where: PositionDataWhereInput): [PositionData!]!
}

type DancerCount {
  parts: Int!
  positionData: Int!
}

enum dancerMutation {
  CREATED
  DELETED
  UPDATED
}

input DancerOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  parts: PartOrderByRelationAggregateInput
  positionData: PositionDataOrderByRelationAggregateInput
}

type DancerPayload {
  dancerData: Dancer
  editBy: Float!
  mutation: dancerMutation!
}

input DancerRelationFilter {
  is: DancerWhereInput
  isNot: DancerWhereInput
}

type DancerResponse {
  dancerData: Dancer
  msg: String
  ok: Boolean!
}

input DancerWhereInput {
  AND: [DancerWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [DancerWhereInput!]
  OR: [DancerWhereInput!]
  parts: PartListRelationFilter
  positionData: PositionDataListRelationFilter
}

input DeleteControlFrameInput {
  frameID: Float!
}

input deleteDancerInput {
  id: Float!
}

type DeleteLEDEffectResponse {
  msg: String
  ok: Boolean!
}

input DeleteLEDInput {
  effectName: String!
  partName: String!
}

input DeletePartInput {
  id: Float!
}

input DeletePositionFrameInput {
  frameID: Float!
}

input EditControlFrameInput {
  fade: Boolean
  frameID: Float!
  start: Float
}

input EditControlMapInput {
  controlData: [[[String!]!]!]!
  fade: Boolean
  startTime: Float!
}

input editDancerInput {
  id: Float!
  name: String!
}

type EditingControlFrame {
  editingFrame: ControlFrame
  frameId: Int
  user: User!
  userId: Int!
}

input EditingControlFrameOrderByWithRelationInput {
  editingFrame: ControlFrameOrderByWithRelationInput
  frameId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingControlFrameRelationFilter {
  is: EditingControlFrameWhereInput
  isNot: EditingControlFrameWhereInput
}

input EditingControlFrameWhereInput {
  AND: [EditingControlFrameWhereInput!]
  editingFrame: ControlFrameRelationFilter
  frameId: IntNullableFilter
  NOT: [EditingControlFrameWhereInput!]
  OR: [EditingControlFrameWhereInput!]
  user: UserRelationFilter
  userId: IntFilter
}

type EditingPositionFrame {
  editingFrame: PositionFrame
  frameId: Int
  user: User!
  userId: Int!
}

input EditingPositionFrameOrderByWithRelationInput {
  editingFrame: PositionFrameOrderByWithRelationInput
  frameId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input EditingPositionFrameRelationFilter {
  is: EditingPositionFrameWhereInput
  isNot: EditingPositionFrameWhereInput
}

input EditingPositionFrameWhereInput {
  AND: [EditingPositionFrameWhereInput!]
  editingFrame: PositionFrameRelationFilter
  frameId: IntNullableFilter
  NOT: [EditingPositionFrameWhereInput!]
  OR: [EditingPositionFrameWhereInput!]
  user: UserRelationFilter
  userId: IntFilter
}

input EditPartInput {
  id: Float!
  name: String!
  type: String!
}

input EditPositionFrameInput {
  frameID: Float!
  start: Float!
}

type Effect {
  alpha: Float!
  colorCode: String!
}

type EffectListData {
  controlFrames: [JSON!]!
  description: String!
  end: Int!
  id: Int!
  positionFrames: [JSON!]!
  start: Int!
}

type EffectListPayload {
  editBy: Float!
  effectListData: EffectListData
  effectListID: ID!
  mutation: String!
}

type EffectListResponse {
  msg: String
  ok: Boolean!
}

input EnumPartTypeFilter {
  equals: PartType
  in: [PartType!]
  not: NestedEnumPartTypeFilter
  notIn: [PartType!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type LEDEffect {
  frames: [JSON!]!
  id: Int!
  name: String!
  partName: String!
  repeat: Int!
}

input LEDEffectCreateframesInput {
  set: [JSON!]!
}

input LEDEffectCreateInput {
  frames: LEDEffectCreateframesInput
  name: String!
  partName: String!
  repeat: Int!
}

input LEDEffectNamePartNameCompoundUniqueInput {
  name: String!
  partName: String!
}

type LEDEffectResponse {
  effectName: String!
  effects: [LEDEffects!]!
  msg: String
  ok: Boolean!
  partName: String!
  repeat: Int!
}

type LEDEffects {
  effect: [Effect!]!
  fade: Boolean!
  start: Float!
}

input LEDEffectUpdateframesInput {
  push: [JSON!]
  set: [JSON!]
}

input LEDEffectUpdateInput {
  frames: LEDEffectUpdateframesInput
  name: StringFieldUpdateOperationsInput
  partName: StringFieldUpdateOperationsInput
  repeat: IntFieldUpdateOperationsInput
}

input LEDEffectWhereUniqueInput {
  id: Int
  name_partName: LEDEffectNamePartNameCompoundUniqueInput
}

type LEDMap {
  LEDMap: LEDMapCustomScalar!
}

"""LED map scalar type"""
scalar LEDMapCustomScalar

type Mutation {
  addColor(color: ColorCreateInput!): Color!
  addControlFrame(fade: Boolean = false, start: Float!): ControlFrame!
  addDancer(dancer: AddDancerInput!): DancerResponse!
  addEffectList(description: String, end: Float!, start: Float!): EffectListData!
  addLED(input: LEDEffectCreateInput!): LEDEffectResponse!
  addPart(part: AddPartInput!): PartResponse!
  addPositionFrame(start: Float!): PositionFrame!
  applyEffectList(clear: Boolean!, id: Float!, start: Float!): EffectListResponse!
  CancelEditControl(FrameID: Float!): RequestEditResponse!
  CancelEditPosition(FrameID: Float!): RequestEditResponse!
  deleteColor(color: String!): ColorResponse!
  deleteControlFrame(input: DeleteControlFrameInput!): ControlFrame!
  deleteDancer(dancer: deleteDancerInput!): DancerResponse!
  deleteEffectList(id: Float!): EffectListResponse!
  deleteLED(input: DeleteLEDInput!): DeleteLEDEffectResponse!
  deletePart(part: DeletePartInput!): PartResponse!
  deletePositionFrame(input: DeletePositionFrameInput!): PositionFrame!
  editColorCodeByColor(color: String!, colorCode: String!): Color!
  editControlFrame(input: EditControlFrameInput!): ControlFrame!
  editControlMap(input: EditControlMapInput!): ControlMap!
  editDancer(dancer: editDancerInput!): DancerResponse!
  editPart(part: EditPartInput!): PartResponse!
  editPositionFrame(input: EditPositionFrameInput!): PositionFrame!
  editPosMap(pos: [[Float!]!]!, start: Float!): PositionMap!
  renameColor(newColor: String!, originalColor: String!): String!
  RequestEditControl(FrameID: Float!): RequestEditResponse!
  RequestEditPosition(FrameID: Float!): RequestEditResponse!
  shift(end: Float!, move: Float!, shiftControl: Boolean!, shiftPosition: Boolean!, start: Float!): ShiftResponse!
  updateOneLEDEffect(data: LEDEffectUpdateInput!, where: LEDEffectWhereUniqueInput!): LEDEffect
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedEnumPartTypeFilter {
  equals: PartType
  in: [PartType!]
  not: NestedEnumPartTypeFilter
  notIn: [PartType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Part {
  _count: PartCount
  controlData(cursor: ControlDataWhereUniqueInput, distinct: [ControlDataScalarFieldEnum!], orderBy: [ControlDataOrderByWithRelationInput!], skip: Int, take: Int, where: ControlDataWhereInput): [ControlData!]!
  dancer: Dancer!
  dancerId: Int!
  id: Int!
  name: String!
  type: PartType!
}

type PartCount {
  controlData: Int!
}

input PartListRelationFilter {
  every: PartWhereInput
  none: PartWhereInput
  some: PartWhereInput
}

input PartOrderByRelationAggregateInput {
  _count: SortOrder
}

input PartOrderByWithRelationInput {
  controlData: ControlDataOrderByRelationAggregateInput
  dancer: DancerOrderByWithRelationInput
  dancerId: SortOrder
  id: SortOrder
  name: SortOrder
  type: SortOrder
}

input PartRelationFilter {
  is: PartWhereInput
  isNot: PartWhereInput
}

type PartResponse {
  msg: String
  ok: Boolean!
  partData: Part
}

enum PartScalarFieldEnum {
  dancerId
  id
  name
  type
}

enum PartType {
  FIBER
  LED
}

input PartWhereInput {
  AND: [PartWhereInput!]
  controlData: ControlDataListRelationFilter
  dancer: DancerRelationFilter
  dancerId: IntFilter
  id: IntFilter
  name: StringFilter
  NOT: [PartWhereInput!]
  OR: [PartWhereInput!]
  type: EnumPartTypeFilter
}

input PartWhereUniqueInput {
  id: Int
}

type PositionData {
  dancer: Dancer!
  dancerId: Int!
  frame: PositionFrame!
  frameId: Int!
  x: Float!
  y: Float!
  z: Float!
}

input PositionDataDancerIdFrameIdCompoundUniqueInput {
  dancerId: Int!
  frameId: Int!
}

input PositionDataListRelationFilter {
  every: PositionDataWhereInput
  none: PositionDataWhereInput
  some: PositionDataWhereInput
}

input PositionDataOrderByRelationAggregateInput {
  _count: SortOrder
}

input PositionDataOrderByWithRelationInput {
  dancer: DancerOrderByWithRelationInput
  dancerId: SortOrder
  frame: PositionFrameOrderByWithRelationInput
  frameId: SortOrder
  x: SortOrder
  y: SortOrder
  z: SortOrder
}

enum PositionDataScalarFieldEnum {
  dancerId
  frameId
  x
  y
  z
}

input PositionDataWhereInput {
  AND: [PositionDataWhereInput!]
  dancer: DancerRelationFilter
  dancerId: IntFilter
  frame: PositionFrameRelationFilter
  frameId: IntFilter
  NOT: [PositionDataWhereInput!]
  OR: [PositionDataWhereInput!]
  x: FloatFilter
  y: FloatFilter
  z: FloatFilter
}

input PositionDataWhereUniqueInput {
  dancerId_frameId: PositionDataDancerIdFrameIdCompoundUniqueInput
}

type PositionFrame {
  _count: PositionFrameCount
  editing: EditingPositionFrame
  id: Int!
  positionDatas(cursor: PositionDataWhereUniqueInput, distinct: [PositionDataScalarFieldEnum!], orderBy: [PositionDataOrderByWithRelationInput!], skip: Int, take: Int, where: PositionDataWhereInput): [PositionData!]!
  start: Int!
}

type PositionFrameCount {
  positionDatas: Int!
}

input PositionFrameOrderByWithRelationInput {
  editing: EditingPositionFrameOrderByWithRelationInput
  id: SortOrder
  positionDatas: PositionDataOrderByRelationAggregateInput
  start: SortOrder
}

input PositionFrameRelationFilter {
  is: PositionFrameWhereInput
  isNot: PositionFrameWhereInput
}

input PositionFrameWhereInput {
  AND: [PositionFrameWhereInput!]
  editing: EditingPositionFrameRelationFilter
  id: IntFilter
  NOT: [PositionFrameWhereInput!]
  OR: [PositionFrameWhereInput!]
  positionDatas: PositionDataListRelationFilter
  start: IntFilter
}

type PositionMap {
  frameIds: PositionMapQueryObjectId!
}

type PositionMapPayload {
  editBy: Float!
  frame: PosMapMutationObjectId!
}

"""Mongo object id scalar type"""
scalar PositionMapQueryObjectId

type PositionRecordPayload {
  addID: [String!]!
  deleteID: [String!]!
  editBy: Float!
  index: Int!
  mutation: String!
  updateID: [String!]!
}

"""Mongo object id scalar type"""
scalar PosMapMutationObjectId

type Query {
  color(where: ColorWhereUniqueInput!): Color
  colorMap: ColorMap!
  colors(cursor: ColorWhereUniqueInput, distinct: [ColorScalarFieldEnum!], orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): [Color!]!
  controlFrame(frameID: Float!): ControlFrame!
  controlFrameIDs: [ID!]!
  ControlMap: ControlMap!
  dancer(dancerName: String!): Dancer!
  dancers: [Dancer!]!
  effectList: [EffectListData!]!
  LEDMap: LEDMap!
  positionFrame(frameID: Float!): PositionFrame!
  positionFrameIDs: [ID!]!
  PosMap: PositionMap!
}

enum QueryMode {
  default
  insensitive
}

type RequestEditResponse {
  editing: String
  ok: Boolean!
}

type ShiftResponse {
  msg: String
  ok: Boolean!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  colorSubscription: ColorPayload!
  controlMapSubscription: ControlMapPayload!
  controlRecordSubscription: ControlRecordPayload!
  DancerSubscription: DancerPayload!
  effectListSubscription: EffectListPayload!
  positionMapSubscription: PositionMapPayload!
  positionRecordSubscription: PositionRecordPayload!
}

type User {
  editingControlFrameId: EditingControlFrame
  editingPositionFrameId: EditingPositionFrame
  id: Int!
  name: String!
  password: String!
}

input UserOrderByWithRelationInput {
  editingControlFrameId: EditingControlFrameOrderByWithRelationInput
  editingPositionFrameId: EditingPositionFrameOrderByWithRelationInput
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  editingControlFrameId: EditingControlFrameRelationFilter
  editingPositionFrameId: EditingPositionFrameRelationFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
}
